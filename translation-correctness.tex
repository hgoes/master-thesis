\section{Übersetzungskonstruktion}
Ein spezifiziertes System mit $N$ Prozessen wird dargestellt als
\[ (\Sigma,D,V) \]
mit den Variablen $V$, der Semantiksymbole $\Sigma$ und den Prozessen
\[ D = (P_1,\dots,P_N) \]
Jeder Prozess ist spezifiziert durch
\[ P_i = (Q_i,\delta_i,\Delta_i,I_i,F_i,Inp_i,Outp_i) \]
wobei $Q_i$ die Zustandsmenge des Prozesses ist, $\delta_i: Q_i\rightarrow \Sigma$ die Semantik für jeden Zustand angibt, $\Delta_i\subseteq Q_i\times Q_i$ die Übergänge zwischen Zuständen darstellt, $I_i,F_i\subseteq Q_i$ die Initial- beziehungsweise Finalzustände kodiert und $Inp_i,Outp_i\subseteq V$ die Ein- und Ausgabevariablen des Prozesses angeben.

Die Semantik eines Systems wird durch ein Tupel
\[ (S,\llbracket \rrbracket_S,\alpha) \]
angegeben.
Hierbei stellt $S$ die globale Zustandsmenge dar, $\llbracket \rrbracket_S:\Sigma\rightarrow (S\rightarrow S\cup \{\bot\})$ gibt eine Übersetzung der Semantiksymbole in Zustandsübergänge an und $\alpha\in S$ kennzeichnet den initialen globalen Zustand.

Der aktuelle Zustand eines Systems lässt sich dann angeben als Kombination des globalen, semantikabhängigen Zustands $s\in S$ und den Prozesszuständen $p_i\in Q_i$:
\[ (s,(p_1,\dots,p_N)) \]
Die Zustandsübergänge dieses Systems folgen nun einer einfachen Regel
\[ \inference[step]{p_i\Delta p_i'&\llbracket \delta_i(p_i')\rrbracket_S(s)\neq\bot}{(s,(p_1,\dots,p_i,\dots,p_n))\rightarrow (\llbracket\delta_i(p_i')\rrbracket_S(s),(p_1,\dots,p_i',\dots,p_n))} \]
Der Initialzustand ist gegeben durch
\[ \inference[init]{}{(\alpha,(\bot,\dots,\bot))} \]
Ein Prozess im initialen Zustand kann in jeden Startzustand schalten:
\[ \inference[start]{p_i=\bot&p_i'\in I_i&\llbracket \delta_i(p_i')\rrbracket_S(s)\neq\bot}{(s,(p_1,\dots,p_i,\dots,p_N))\rightarrow (\llbracket \delta_i(p_i')\rrbracket_S(s),(p_1,\dots,p_i',\dots,p_N))} \]

Um ein solches Modell nun nach Promela zu übersetzen, benötigt man zusätzlich noch drei weitere semantikspezifische Konstrukte:
\begin{enumerate}
\item Eine Funktion $\llbracket\rrbracket_C : \Sigma\rightarrow \textrm{PrExpr}$, die Semantiksymbole in Promela-Ausdrücke übersetzt, die genau dann ausgeführt werden können, wenn nach der Semantik ein Zustand betreten werden darf.
\item Eine Funktion $\llbracket\rrbracket_A : \Sigma\rightarrow \textrm{PrStmt}^{*}$, die für jedes Semantiksymbol die Anweisungen generiert, die den globalen Zustand transformieren.
  Die Anweisungen dürfen unter keinen Umständen blockieren.
\item Außerdem eine Funktion $\llbracket\rrbracket_D : S\rightarrow \textrm{PrDecl}^{*}$, die des globalen Startzustand in eine Folge von Promela-Deklarationen übersetzt.
  Diese sind allerdings in so fern eingeschränkt, dass sie nur Variablen oder Kanäle definieren dürfen, aber keine zusätzlichen Prozesse.
\end{enumerate}

Mit diesen Hilfsmitteln lässt sich nun die Übersetzung des Modells nach Promela darstellen als eine Funktion $tr(\Sigma,D,V)$, mit der folgenden Definition:
\begin{lstlisting}[language=Promela,mathescape=true]
$\llbracket \alpha \rrbracket_D$
$[ \forall P=(Q,\delta,\Delta,I,F,Inp,Outp)\in D:$
active proctype $P$() {
  if $[ \forall i\in I:$
     :: goto st_$i$
     $]$
  fi;
  $[ \forall q\in Q:$
  st_$q$: atomic {
    $\llbracket \delta(q) \rrbracket_C$;
    $\llbracket \delta(q) \rrbracket_A$
    if $[ \forall q'\in Q, q\Delta q':$
       :: goto st_$q'$
       $]$
    fi
  };
  $]$
}
$]$
\end{lstlisting}
\subsection{Richtigkeit der Übersetzung}
Um zu beweisen, dass die angegebene Promela-Übersetzung korrekt ist, muss gezeigt werden, dass die eben definierte Semantik des Modells mit der Semantik des übersetzten Promela-Modells übereinstimmt.
Um dies zu zeigen, wird die Promela-Semantik verwendet, wie sie in \cite{Weise97anincremental} beschrieben ist.

Als erstes werden die globalen Deklarationen und Prozessdefinitionen mithilfe der Regel \emph{PTYPE1} abgearbeitet, was zu einem Zustand
\[ (\epsilon,\mathcal{G}_0,\mathcal{C}_0,\textrm{pdef},\textrm{act}_0,\bot) \]
führt.
Dabei enthält \emph{pdef} die Prozessdefinitionen und da alle Prozesse aktiv deklariert sind, ist \emph{act} eine Liste, die für jeden Prozess mit dem Rumpf $\pi$ den Eintrag $(\pi,\pi,\emptyset,\epsilon)$ enthält.

Ein Prozess kann sich nur in zwei verschiedenen Zuständen befinden:
\begin{itemize}
\item Ganz am Anfang seines Rumpfes.
  Diesen Zustand hat der Prozess nur am Anfang seiner Ausführung, da kein Rücksprung zum Anfang des Rumpfes stattfindet.
\item Am Anfang eines Zustands-Labels.
  Da die Anweisungsfolge jedes Zustands mit \emph{atomic} gekennzeichnet ist, kann der Prozess sich nicht in einem Zwischenzustand aufhalten.
\end{itemize}

Diese zwei Zustände entsprechen den Zuständen der Prozesse im anderen Modell:
Am Anfang befinden sich diese im Zustand $\bot$, danach in einem Zustand aus $Q$.
Da die Zustand-Labels aus $Q$ generiert werden, haben die Prozesse in beiden Modellen also gleich viele Zustände.