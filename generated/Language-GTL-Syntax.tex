\haddockmoduleheading{Language.GTL.Syntax}
\label{module:Language.GTL.Syntax}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module Language.GTL.Syntax (
    Declaration(Model, Connect, Verify), 
    ModelDecl(ModelDecl,
              modelName,
              modelType,
              modelArgs,
              modelContract,
              modelInits,
              modelInputs,
              modelOutputs), 
    ConnectDecl(ConnectDecl,
                connectFromModel,
                connectFromVariable,
                connectToModel,
                connectToVariable), 
    VerifyDecl(VerifyDecl, verifyFormulas), 
    GExpr(GBin, GUn, GConst, GConstBool, GVar, GSet, GExists), 
    Expr(ExprVar,
         ExprConst,
         ExprBinInt,
         ExprBinBool,
         ExprRel,
         ExprElem,
         ExprNot,
         ExprAlways,
         ExprNext), 
    parseGTLType,  castSer,  toBoolOp,  toRelOp,  toElemOp,  ExistsBinding, 
    typeCheckBool,  typeCheckInt,  typeCheck,  typeCheck', 
    GTLType(typeCheckBin, typeCheckUn),  toIntOp,  BoolOp(And, Or, Implies), 
    IntOp(OpPlus, OpMinus, OpMult, OpDiv), 
    Relation(BinLT, BinLTEq, BinGT, BinGTEq, BinEq, BinNEq), 
    InitExpr(InitAll, InitOne),  relNot,  relTurn,  pushNot,  getVars, 
    maximumHistory,  mapVars
  ) where\end{verbatim}}
\haddockendheader

Data types representing a parsed GTL file.
\par

\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ Declaration
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Model ModelDecl} & Declares a model.
 \\
\haddockdecltt{|} & \haddockdecltt{Connect ConnectDecl} & Declares a connection between two models.
 \\
\haddockdecltt{|} & \haddockdecltt{Verify VerifyDecl} & Declares a property that needs to be verified.
 \\
\end{tabulary}\par
A GTL file is a list of declarations.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Show\ Declaration
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ ModelDecl
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{ModelDecl} & \\
                    \{ & \haddockdecltt{modelName :: String} & The name of the model in the GTL formalism.
 \\
                    , & \haddockdecltt{modelType :: String} & The synchronous formalism the model is written in (for example \emph{scade})
 \\
                    , & \haddockdecltt{modelArgs :: [String]} & Arguments specific to the synchronous formalism, for example in which file the model is specified etc.
 \\
                    , & \haddockdecltt{modelContract :: [GExpr]} & A list of contracts that this model fulfills.
 \\
                    , & \haddockdecltt{modelInits :: [(String, InitExpr)]} & A list of initializations for the variables of the model.
 \\
                    , & \haddockdecltt{modelInputs :: Map String TypeRep} & Declared inputs of the model with their corresponding type
 \\
                    , & \haddockdecltt{modelOutputs :: Map String TypeRep} & Declared outputs of a model
 \\
                    \} &
\end{tabulary}\par
Declares a synchronous model.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Show\ ModelDecl
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ ConnectDecl
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{ConnectDecl} & \\
                    \{ & \haddockdecltt{connectFromModel :: String} & Model of the source variable
 \\
                    , & \haddockdecltt{connectFromVariable :: String} & Name of the source variable
 \\
                    , & \haddockdecltt{connectToModel :: String} & Model of the target variable
 \\
                    , & \haddockdecltt{connectToVariable :: String} & Name of the target variable
 \\
                    \} &
\end{tabulary}\par
Declares a connection between two variables
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Show\ ConnectDecl
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ VerifyDecl
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{VerifyDecl} & \\
                    \{ & \haddockdecltt{verifyFormulas :: [GExpr]} & The formulas to be verified.
 \\
                    \} &
\end{tabulary}\par
A list of formulas to verify.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Show\ VerifyDecl
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ GExpr
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{GBin BinOp GExpr GExpr} & \\
\haddockdecltt{|} & \haddockdecltt{GUn UnOp GExpr} & \\
\haddockdecltt{|} & \haddockdecltt{GConst Int} & \\
\haddockdecltt{|} & \haddockdecltt{GConstBool Bool} & \\
\haddockdecltt{|} & \haddockdecltt{GVar (Maybe String) String} & \\
\haddockdecltt{|} & \haddockdecltt{GSet [Integer]} & \\
\haddockdecltt{|} & \haddockdecltt{GExists String (Maybe String) String GExpr} & \\
\end{tabulary}\par
An untyped expression type.
   Used internally in the parser.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Eq\ GExpr\\instance\ Ord\ GExpr\\instance\ Show\ GExpr
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ Expr\ v\ a\ where
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
& \haddockdecltt{ExprVar :: v -> Integer -> Expr v a} & \\
& \haddockdecltt{ExprConst :: a -> Expr v a} & \\
& \haddockdecltt{ExprBinInt :: IntOp
                               -> Expr v Int -> Expr v Int -> Expr v Int} & \\
& \haddockdecltt{ExprBinBool :: BoolOp
                                -> Expr v Bool
                                   -> Expr v Bool -> Expr v Bool} & \\
& \haddockdecltt{ExprRel :: Relation
                            -> Expr v Int -> Expr v Int -> Expr v Bool} & \\
& \haddockdecltt{ExprElem :: v -> [Integer] -> Bool -> Expr v Bool} & \\
& \haddockdecltt{ExprNot :: Expr v Bool -> Expr v Bool} & \\
& \haddockdecltt{ExprAlways :: Expr v Bool -> Expr v Bool} & \\
& \haddockdecltt{ExprNext :: Expr v Bool -> Expr v Bool} & \\
\end{tabulary}\par
A type-safe expression type.
   \emph{v} is the type of variables (for example \haddockid{String}) and \emph{a} is the type of the expression.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Typeable2\ Expr\\instance\ (Eq\ a,\ Eq\ v)\ =>\ Eq\ (Expr\ v\ a)\\instance\ (Ord\ a,\ Ord\ v)\ =>\ Ord\ (Expr\ v\ a)\\instance\ (Show\ a,\ Show\ v)\ =>\ Show\ (Expr\ v\ a)\\instance\ (Binary\ a,\ Binary\ v,\ Typeable\ a)\ =>\ Binary\ (Expr\ v\ a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[
parseGTLType\ ::\ String\ ->\ Maybe\ TypeRep
]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
castSer\ ::\ (Typeable\ a,\ Typeable\ b,\ Monad\ m)\ =>\ c\ a\ ->\ m\ (c\ b)
\end{tabular}]\haddockbegindoc
Lift \haddockid{gcast} in a monad and fail with an error if the cast fails
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
toBoolOp\ ::\ BinOp\ ->\ Maybe\ BoolOp
\end{tabular}]\haddockbegindoc
Cast a binary operator into a boolean operator. Returns \haddockid{Nothing} if the cast fails.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
toRelOp\ ::\ BinOp\ ->\ Maybe\ Relation
\end{tabular}]\haddockbegindoc
Cast a binary operator into a relation. Returns \haddockid{Nothing} if the cast fails.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
toElemOp\ ::\ BinOp\ ->\ Maybe\ Bool
\end{tabular}]\haddockbegindoc
Cast a binary operator into an element operator. Returns \haddockid{Nothing} if the cast fails.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type\ ExistsBinding\ a\ =\ Map\ String\ (a,\ Integer)
\end{tabular}]\haddockbegindoc
Binds variables to other variables from the past.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[
typeCheckBool\ ::\ ExistsBinding\ (Maybe\ String,\ String)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ GExpr\ ->\ Either\ String\ (Expr\ (Maybe\ String,\ String)\ Bool)
]
\item[
typeCheckInt\ ::\ ExistsBinding\ (Maybe\ String,\ String)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ GExpr\ ->\ Either\ String\ (Expr\ (Maybe\ String,\ String)\ Int)
]
\item[
typeCheck\ ::\ (Ord\ a,\ Show\ a,\ GTLType\ t,\ Show\ t)\ =>\ Map\ a\ TypeRep\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ (Maybe\ String\ ->\ String\ ->\ Either\ String\ a)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ GExpr\ ->\ Either\ String\ (Expr\ a\ t)
]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
typeCheck'
\end{tabular}]\haddockbegindoc
\haddockbeginargs
\haddockdecltt{::} & \haddockdecltt{(Ord a, Show a, GTLType t, Show t)} \\
                     \haddockdecltt{=>} & \haddockdecltt{Map a TypeRep} & Type mapping
 \\
                                                                          \haddockdecltt{->} & \haddockdecltt{(Maybe String
                                                                                                               -> String
                                                                                                                  -> Either String a)} & \\
                                                                                                                                         \haddockdecltt{->} & \haddockdecltt{ExistsBinding a} & A map of bound variables
 \\
                                                                                                                                                                                                \haddockdecltt{->} & \haddockdecltt{GExpr} & The expression to convert
 \\
                                                                                                                                                                                                                                             \haddockdecltt{->} & \haddockdecltt{t} & undefined
 \\
                                                                                                                                                                                                                                                                                      \haddockdecltt{->} & \haddockdecltt{Either String (Expr a t)} & \\
\end{tabulary}\par
Typecheck an untyped expression. Converts it into the \haddockid{Expr} type which is strongly typed.
   Returns either an error message or the resulting expression of type \haddockid{Bool}.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
class\ Typeable\ t\ =>\ GTLType\ t\ where
\end{tabular}]\haddockbegindoc
\haddockpremethods{}\textbf{Methods}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
typeCheckBin\ ::\ (Ord\ a,\ Show\ a,\ GTLType\ t)\ =>\ Map\ a\ TypeRep\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ (Maybe\ String\ ->\ String\ ->\ Either\ String\ a)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ ExistsBinding\ a\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ t\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ BinOp\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ GExpr\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ GExpr\ ->\ Either\ String\ (Expr\ a\ t)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
typeCheckUn\ ::\ (Ord\ a,\ Show\ a,\ GTLType\ t)\ =>\ Map\ a\ TypeRep\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ (Maybe\ String\ ->\ String\ ->\ Either\ String\ a)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ ExistsBinding\ a\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ->\ t\ ->\ UnOp\ ->\ GExpr\ ->\ Either\ String\ (Expr\ a\ t)
\end{tabular}]
\end{haddockdesc}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ GTLType\ Bool\\instance\ GTLType\ Int
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
toIntOp\ ::\ BinOp\ ->\ Maybe\ IntOp
\end{tabular}]\haddockbegindoc
Cast a binary operator into an arithmetic operator. Returns \haddockid{Nothing} if the cast fails.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ BoolOp
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{And} & ⋀ \\
\haddockdecltt{|} & \haddockdecltt{Or} & ⋁ \\
\haddockdecltt{|} & \haddockdecltt{Implies} & ⇒ \\
\end{tabulary}\par
Binary boolean operators with the traditional semantics.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Enum\ BoolOp\\instance\ Eq\ BoolOp\\instance\ Ord\ BoolOp\\instance\ Show\ BoolOp\\instance\ Binary\ BoolOp
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ IntOp
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{OpPlus} & +
 \\
\haddockdecltt{|} & \haddockdecltt{OpMinus} & - \\
\haddockdecltt{|} & \haddockdecltt{OpMult} & * \\
\haddockdecltt{|} & \haddockdecltt{OpDiv} & / \\
\end{tabulary}\par
Arithmetik binary operators.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Enum\ IntOp\\instance\ Eq\ IntOp\\instance\ Ord\ IntOp\\instance\ Show\ IntOp\\instance\ Binary\ IntOp
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ Relation
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{BinLT} & < \\
\haddockdecltt{|} & \haddockdecltt{BinLTEq} & <=
 \\
\haddockdecltt{|} & \haddockdecltt{BinGT} & > \\
\haddockdecltt{|} & \haddockdecltt{BinGTEq} & >=
 \\
\haddockdecltt{|} & \haddockdecltt{BinEq} & =
 \\
\haddockdecltt{|} & \haddockdecltt{BinNEq} & !=
 \\
\end{tabulary}\par
Integer relations.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Enum\ Relation\\instance\ Eq\ Relation\\instance\ Ord\ Relation\\instance\ Show\ Relation\\instance\ Binary\ Relation
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data\ InitExpr
\end{tabular}]\haddockbegindoc
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{InitAll} & The variable is initialized with all possible values.
 \\
\haddockdecltt{|} & \haddockdecltt{InitOne Integer} & The variable is initialized with a specific value.
 \\
\end{tabulary}\par
Information about the initialization of a variable.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance\ Eq\ InitExpr\\instance\ Show\ InitExpr
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
relNot\ ::\ Relation\ ->\ Relation
\end{tabular}]\haddockbegindoc
Negates a relation
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
relTurn\ ::\ Relation\ ->\ Relation
\end{tabular}]\haddockbegindoc
Switches the operands of a relation.
   Turns x \url{ y into y } x.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
pushNot\ ::\ Expr\ v\ Bool\ ->\ Expr\ v\ Bool
\end{tabular}]\haddockbegindoc
Pushes a negation as far into the formula as possible by applying simplification rules.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
getVars\ ::\ Expr\ v\ a\ ->\ {\char 91}(v,\ Integer){\char 93}
\end{tabular}]\haddockbegindoc
Extracts all variables with their level of history from an expression.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
maximumHistory\ ::\ Ord\ v\ =>\ Expr\ v\ a\ ->\ Map\ v\ Integer
\end{tabular}]\haddockbegindoc
Extracts the maximum level of history for each variable in the expression.
\par

\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
mapVars\ ::\ (v\ ->\ w)\ ->\ Expr\ v\ a\ ->\ Expr\ w\ a
\end{tabular}]\haddockbegindoc
Change the type of the variables in an expression.
\par

\end{haddockdesc}